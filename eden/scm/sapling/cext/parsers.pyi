# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 2.

from typing import Callable, Dict, Iterable, Set, Tuple, Union

# dirstatetuple is really a custom type separate from Tuple, but it behaves
# basically like a Tuple, and we can't really get the same type checking behavior
# without using Tuple.
# (state, mode, size, mtime)
dirstatetuple = Tuple[str, int, int, int]

def isasciistr(s: Union[bytes, str]) -> bool: ...
def asciilower(s: bytes) -> bytes: ...
def asciiupper(s: bytes) -> bytes: ...
def jsonescapeu8fast(origstr: bytes, paranoid: bool) -> bytes: ...
def make_file_foldmap(
    dmap: Dict[str, dirstatetuple], spec: int, normcase_fallback: Callable[[str], str]
) -> Dict[str, str]: ...
def dict_new_presized(minsize: int) -> Dict[str, dirstatetuple]: ...
def parse_dirstate(
    dmap: Dict[str, dirstatetuple], copymap: Dict[str, str], st: bytes
) -> Tuple[bytes, bytes]: ...
def pack_dirstate(
    dmap: Dict[str, dirstatetuple],
    copymap: Dict[str, str],
    pl: Tuple[bytes, bytes],
    now: int,
) -> bytes: ...
def nonnormalotherparententries(
    dmap: Dict[str, dirstatetuple]
) -> Tuple[Set[str], Set[str]]: ...

class lazymanifest:
    def __init__(self, data: bytes) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key: str) -> Tuple[bytes, str]: ...
    def __setitem__(self, key: str, hash_and_flags: Tuple[bytes, str]) -> None: ...
    def __contains__(self, key: str) -> bool: ...
    def keys(self) -> Iterable[str]: ...
    def iterkeys(self) -> Iterable[str]: ...
    def iterentries(self) -> Iterable[Tuple[str, bytes, str]]: ...
    def copy(self) -> "lazymanifest": ...
    def filtercopy(self) -> "lazymanifest": ...
    def diff(
        self, other: "lazymanifest", listclean: bool = False
    ) -> Dict[str, Tuple[Tuple[bytes, str], Tuple[bytes, str]]]: ...
    def text(self) -> bytes: ...
